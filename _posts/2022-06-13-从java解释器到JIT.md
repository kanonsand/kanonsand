---
layout: post
title: "从java解释器到JIT"
tags: ["java", "jvm", "jit"]
---

hotspot虚拟机字节码解释器的进化过程。

### 编译型和解释型语言
计算机可以直接执行的只有机器码，所以任何程序要想运行，最终必须转为机器码，而且机器码是平台相关的。编译型语言由编译器直接将源码转为机器码，
启动后直接运行，如C和C++， 解释型语言则将源码转为一种中间形式的表示（可选的，转为中间表示通常是为了进行优化，比如Java，转为字节码的过程
中就使用了大量的编译器优化技巧。而大部分脚本则没有这一步）， 运行时由解释器实时解释成机器码执行。java程序编译后的文件是字节码，由jvm解释
成机器码后执行。

### 最初的字节码解释器
最早的字节码解释器由C写成，本质是一个无限循环加一个巨大的switch语句，每个case对应字节码，执行对应的操作。

### 优化后的解释器
再晚一些的解释器由C++写成，和C写成的区别不大，主要是通过一些技巧（主要是平台相关的特性）提高了性能。

### 模板解释器
从jdk1.4（大概）开始，使用[模板解释器](https://en.wikipedia.org/wiki/Interpreter_(computing)#Template_Interpreter)，
这种解释器直接根据平台硬编码case语句，像一个哈希表，直接将每个字节码映射为代码包（codelets，一段机器码），提升了性能，但是每个平台的实现不一样，
提高了维护成本。我们可以通过启动jvm时添加参数-XX:+UnlockDiagnosticVMOptions -XX:+PrintInterpreter让jvm打印这部分的信息，
windows系统上java17输出如下
```
----------------------------------------------------------------------
Interpreter

code size        =     99K bytes
total space      =     98K bytes
wasted space     =      0K bytes

# of codelets    =    271
avg codelet size =    374 bytes
```
可以看到codelets数量是271，这比字节码数量要多。这是因为其中包含了一些优化的组合指令，比如Math包下面求sin、cos等函数。

模板解释器性能提升巨大，几乎是c++版本的两倍。

### 解释器的不足
尽管解释器已经发展到了模板解释器，但是相比静态编译语言（比如c和c++），解释器的运行速度还是很慢，这是因为解释器将每个字节码单独
处理，而静态语言编译器可以分析一整块代码并优化，解释器永远不可能达到静态编译语言的运行速度。

### 引入JIT编译器
为了在保持java“一次编译，到处运行”的特性的同时提高其运行速度，Java引入了JIT（just-in-time）编译器。JIT编译器在jvm运行时将
某段代码编译成机器码，这个过程类似于静态语言编译（c和c++等），编译完成后能达到（[甚至超过](java解释器历史.md:59)）c和c++的
运行速度。由于JIT是在jvm启动后 运行的，而编译过程也需要使用cpu资源，如果所有代码在jvm启动后里面通过JIT编译，那么应用启动速度会
很慢，而且有很多代码我们只会运行一次 或者几次，将这些代码编译耗费的时间可能超过了代码真正的执行时间，得不偿失。因此JIT编译器只会作
用于*热点代码*，即调用频繁的代码。

### JIT编译器如何工作
jdk中有两个JIT编译器，分别是c1和c2，c1速度快但是优化效果一般，c2优化策略更加激进但是速度较慢。jvm运行在client模式下只启用c1
编译器；jdk7和之前server模式下只启用c2编译器，jdk7之后server模式下同时使用c1和c2。

JIT编译对象是方法，在上一节我们提到，JIT作用于热点代码。jvm会为每个方法保存一个计数，当计数达到JIT工作的阈值（默认c1阈值1500次，
c2阈值10000次。在c1和c2混合模式下，首先达到c1阈值进行编译，如果这个代码还在不断被调用，达到c2阈值，我们认为值得花费更长的时间对其
进行进一步编译优化，此时会使用c2编译器进行一次更加激进的优化编译）。

### JIT——更强大的代码优化
上面我们说到，JIT会将热点代码编译成机器码来达到native的运行速度。但是如果认为JIT只有这些功能就有点小看它了，实际上，JIT还可以根据
方法的运行时信息优化编译过程。考虑如下方法代码：
```java
    public void methodA(boolean flag){
        if(flag){
        //分支a
        }else{
        //分支b
        }
    }
```
如果只根据代码编译，JIT必须将两个分支都进行编译，实际上如果运行时JIT发现这个方法每次都走分支a，JIT可以不编译另外一个分支，提高了
代码密度。当然，后续这个方法还是可能走另外一个分支，JIT为了应对这种情况，会在分支b放一个trap，如果后续走到了这个分支，JIT会重新编译
分支b的代码。

另一种情况，分支b的调用频率远大于分支a，JIT可能重构编译后代码的布局，将分支b放在分支a的前面，提高性能。

这里就是JIT和传统AOT（ahead of time） 编译器的另一个区别：
>AOT编译完成后不会再改变，而JIT可以根据运行时状态重新优化编译已经编译完成的代码。

通过运行时信息，JIT编译器不断优化生成的机器码，因此***java服务器运行平稳后峰值性能甚至可以超过静态编译语言的服务器***。

### redefine 和 retransform 对JIT的影响
redefine或retransform一个类后，JIT对这个类已经编译的代码会全部失效，因此如果是线上高频调用的类，需要谨慎使用redefine和retransform。