



因为jvm是多线程的，所以可能有多个线程尝试初始化一个类，jvm规范中规定了，对于一个类或者接口C，需要有一个排他的初始化锁LC，LC的具体实现没有要求。初始化过程如下：

1、阻塞等待获取C的锁LC

2、如果C对应的Class对象状态表明C正在被其他线程初始化，则释放LC，直到其他线程的初始化结束。线程的中断状态不会受初始化过程的影响

3、如果C的Class对象表明C正在被当前线程处理，说明进入了递归调用的状态，释放锁即可（即可重入锁，第二次加锁发现已经持有锁，释放一次即可）

4、如果Class对象表明C已经被初始化，直接释放锁

5、如果Class对象是一个错误状态，表明C无法初始化，抛出NoClassDefFoundError

6、其他情况，在Class对象记录当前线程为处理中的线程，然后释放LC,之后，初始化所有static final常量（常量只包括基本数据类型和String），
按照在class文件中的顺序（一般是声明顺序）

7、如果C是一个类，不是接口，并且其父类尚未初始化，那么列举出C的所有直接或间接的至少包含一个非static并且非abstract方法（在j
ava8中，即default方法，因为接口中没有方法体的方法默认是abstract的，有方法体的方法要么是default，要么是static）的父接口
和其直接父类，都执行初始化方法（按照某种继承顺序，具体没有深入），如果中间发生了错误，则申请LC锁，将Class对象状态设为错误，
notify所有等待的线程，释放LC，直接停止执行，抛出NoClassDefFoundError

8、查询C的类加载器来确认C是否开启了断言（assertion）

9、执行C的初始化方法

10、如果C的初始化方法成功执行完成，申请LC锁，将C的Class对象标记为完成初始化，然后notify所有等待的线程，释放LC

11、如果初始化过程抛出了异常，首先确认异常的类型，如果该异常不是Error或者Error的子类，那么新建一个ExceptionInInitializerError，代替原来的异常抛出。如果因为OOM导致这个Error对象无法成功创建，则使用OOM代替这个Error，之后申请LC，将Class对象状态设为错误，notify所有线程，释放LC，之后抛出上面确定的异常。


*** jvm实现可能会优化掉其中部分加锁释放锁的操作。***

绑定native方法 