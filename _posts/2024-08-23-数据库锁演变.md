
数据库并发访问时，为了保证数据一致性，如果多个事务同时访问某条数据，有必要通过加锁来避免访问冲突，
而不同的锁有不同的tradeoff

### 普通锁
即通常意义上的同步锁，尝试访问某条数据时，无论是读还是写，都需要先获得这条数据的锁

#### 优点
简单直接
#### 缺点
如果多个并发只是为了读取数据，也需要按顺序获取锁，读取然后释放，这种同步是没必要的

### 读写锁
对同步锁的优化，无锁状态下可以有多个读者同时获取读锁，获取写锁则阻塞后续所有的读锁，并且等待当前
所有已获取的读锁全部释放后写锁获取成功

#### 相容矩阵
列为当前持有的锁，行为当前要申请的锁，o表示申请成功，x表示申请失败

| - |r| w |
|---|---|---|
| r |o| x |
| w |x| x |

#### 锁升级
考虑这样的场景：事务首先读取一个值，执行自己的计算逻辑后准备将新的值写入,读取的时候先申请读锁，
当写入的值计算好后，将读锁升级为写锁。当然我们可以直接申请写锁，但是这种情况下，写锁需要等待其他
读锁全部释放才能读取到值，相比之下使用升级锁可以更早的读取到字段值并开始计算

#### 优点
优化了同步读的情况

#### 缺点
锁升级会有问题，假设事务t1和t2都读取数据然后写入，即都申请读锁然后执行锁升级，在锁升级时，会等待
其他事务的读锁都释放，而此时两个事务持有读锁并且申请升级，导致互相等待对方释放读锁最后死锁

### 读写锁加更新锁
在读写锁的基础上引入一个更新锁，读锁无法升级到写锁，更新锁可以升级到写锁，更新锁的加锁逻辑和写锁
类似，当前只有读锁的情况下可以加更新锁，加完更新锁后阻塞后续所有类型的锁。持有更新锁时可以读但不
可以写，相比于写锁，更新锁在当前其他读锁未释放的情况下即可加锁成功并开始读取数据，而写锁则需要等待
其他读锁全部释放后才可以加锁成功

#### 相容矩阵
列为当前持有的锁，行为当前要申请的锁，o表示申请成功，x表示申请失败

|-|r|u|w|
|---|---|---|---|
|r|o|o|x|
|u|x|x|x|
|w|x|x|x|


### 树形结构下锁的优化
目前为止我们的讨论都是基于理论上的，实际实现中，数据库数据经常被表示为树结构，我们讨论以下两种树
结构
1、数据本身的树结构，我们要支持不同粒度的锁，小范围，大范围，单个，甚至所有数据
2、并发控制中的树结构，

#### 多粒度锁
不同情况下最优的锁粒度不同，更小的粒度可以实现更高的并发，但是我们也有获取整个关系一致性视图的需求，此时需要一个整个关系的锁，单独采用某一种锁无法很好地用于通用的情况，我们需要混合使用多种锁，此时这些锁需要某种方式协调管理

#### 警示锁
假设我们有从大到小三种粒度的锁：整个关系的锁r(elation)，基于数据块或者数据范围的锁b(lock),单个数据记录的锁t(uple),为了解决他们之间的协作，我们将其组织为一个树形结构
r锁为根节点，子节点为b1到bn，t1到tm每个都是b1到bn中某个节点的子节点，加锁时我们按照树的层级从根节点开始逐层往下。
这里只考虑r/w锁，如果只使用这两个锁，对该结构的请求退化为对整个关系的锁，因为每次都要从根节点开始往下申请，这里我们引入警示锁（也叫意向锁），r/w的警示锁分别表示为ir,iw,该协议的加锁规则是：
> 要在任何元素上加r或w锁，我们必须从整个锁构成的树根节点开始
> 如果我们位于要申请的锁的位置，直接加r或w锁
> 如果目标位置位于当前位置的子树中，我们需要在当前位置添加警示锁，例如如果要对子树中的元素添加r锁，则当前位置添加ir锁，w锁同理
> 反复执行2，3步骤知道成功对目标位置添加r或w锁

相容性矩阵

|-|ir|iw|r|w|
|---|---|---|---|---|
|ir|o|o|o|x|
|iw|o|o|x|x|
|r|o|x|o|x|
|w|x|x|x|x|

考虑ir列，我们请求节点N上的ir锁时，表示我们想对N的某个后继添加r锁，显然其他事务的ir和r锁并不会和本事务造成冲突，w锁则表示其他事务已经要写该节点，显然此时ir不能成功，考虑iw，iw表示其他事务想要申请N的某个后继的w锁,该元素与我们要申请锁的元素不一定相同，所以，我们允许ir和iw共存，期望冲突在更低层次进行解决

考虑iw列，对于ir和iw，因为他们只是声明要对N节点的某个后继加锁，他们加锁的元素不一定相同，所以我们允许他们共存，让冲突在更低层次进行解决;而iw表示我们将要在某个后继进行写操作，所以我们需要禁止对整个范围的读写操作，因此对于已有r或者w，iw无法加锁成功

考虑r列，ir和r都只读，允许r加锁成功，如果iw被其他事务持有，表明其他事务在修改当前节点的某个后继，此时无法安全读取整个范围内的数据,w则表示其他事务在修改当前整个范围，此时也无法加锁成功

w列与其他所有锁冲突，必须等到其他锁全部释放后才可加锁成功
