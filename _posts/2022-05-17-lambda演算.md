---
layout: post
title: "lambda演算"
tags: ["lambda"]
---

简单介绍lambda、闭包的概念，理解函数式编程的原理。
### lambda三元素

lambda由三个基本元素组成：变量variable、表达式expression和方法。

+ 这里的变量并不是我们平常使用的用于暂时存放值的那个变量，而是方法的参数

+ 方法由方法头和方法体构成，方法头是λ加变量，方法体是表达式。并且方法体只有一个参数，一个方法通常如下

  ```
  λx.x
  λx是方法头，第二个x为方法体，中间使用点分隔。这个例子返回变量本身，称为identity function
  ```

+ 表达式会一直求值，直到出现一个不可约的对象作为结果

  ```
  (λx.x) 3
  这个例子中，(λx.x)是方法，3是参数
  ```

  

### 变量类型

目前为止我们已经看到使用了一个参数的方法，当方法被应用于表达式时，方法体中的该变量会全部被替换为表达式，这种变量称为绑定变量 bound variable

```
通俗的说，(λx.x) 3这个例子中，方法有一个参数，开始求值时，3作为参数x传入，之后3会被代入方法体中的x进行运算
```

另一种变量是自由变量 free variable，它们出现在方法体中，而不是方法头中，或者说，它们无法被绑定，因为它们引用的对象通常位于方法之外，并不是这个方法的本地变量。

```
λx.xz
例如这个例子，z不是在方法头中声明的，所以它无法在方法执行过程中被绑定和替换
```

### Alpha和Beta简化

我们已经讨论了表达式，后续我们将通过表达式来构建更复杂的运算，为了能让表达式尽可能简单，我们引入两种简化

+ Alpha等价

  如果两个表达式互换参数后返回的结果和原来是一样的，我们称其为Alpha等价

  ```
  λx.x   λa.a   λz.z //三个函数Alpha等价
  λxyz.yzx   λabc.bca //两个函数Alpha等价
  对于任意值value，将其代入上面任意一个函数，返回值均相同，所以它们Alpha等价。类似于日常编程中只是改变了方法的参数名称，并不影响方法的功能
  ```

  Alpha等价的方法可以相互替换而不影响返回结果。这一特性会用于后续的Beta简化。

  当我们引入自由变量之后，只有当引入的自由变量相同时才Alpha等价

  ```
  λxy.yxz  λab.baz
  z是自由变量，因为两个方法引用了同一个自由变量，所以两个方法可以互相替换，因此Alpha等价
  λxy.yxz λab.bac
  z和c均为自由变量，因为他们不是一个自由变量，所以无法互相替换，也就Alpha不等价
  ```

  Alpha等价通俗的讲，如果将调用方法A替换为引用方法B或者反过来，都不影响结果，那么方法A和方法B就是Alpha等价的。

+ Beta简化

  计算（化简）lambda表达式的过程被称为Beta简化，将其称为简化是因为将参数绑定到方法提后，消除了方法头。

  ```
  (λx.x) 3
  [x:=3]
  3
  这个过程也称为将3应用到变量x。[x:=3]表示我们将方法体中的x都替换为3
  ```

  化简复杂的表达式，使用Alpha等价来解决变量冲突，自由变量无法被化简

  ```
  (λx.xy)(λx.xz)(λy.y)  从左往右设为ABC
  首先将B应用于A，将B整体使用Beta简化代入A，即去掉A的方法头，将方法体中的变量替换为B
  [x:=(λx.xz)]
  ((λx.xz)y)(λy.y) 从左往右设为DC，C和上面相同，D为新的函数，同样将C代入D
  [x:=(λy.y)]
  (((λy.y)z)y) 注意这里，必须是一个完整的表达式才能简化，即需要方法和参数，这里
  				的表达式只有(λy.y)z，所以对其进行化简
  [y:=z]
  zy  最终结果
  注意最开始的ABC，对于A来说，y是自由变量，对于C来说，y是绑定变量
  
  ```

  例中最后结果为zy，已经是一个完全求值表达式，这种称为Beta范式

### 多参数

目前为止我们讨论的都是单个参数的情况，而且lambda也只能有一个绑定变量，对于多参数，我们将其函数头转为嵌套的函数头。

```
λxy.yx
这个双参数的lambda可以转为
λx.λy.yx或者λx.(λy.yx)
```

这种转换称为柯里化。

但是并不是所有的lambda表达式都可以柯里化

```
(λx.xx)(λx.xx)
[x:=(λx.xx)]
(λx.xx)(λx.xx)
...
这个表达式永远无法结束，这种情况称为表达式发散。有些情况下更坏
(λx.xxx)(λx.xxx)
[x:=(λx.xxx)]
(λx.xxx)(λx.xxx)(λx.xxx)
...
每一次迭代表达式会变长。
这些无法结束的lambda最终会导致stackoverflow
```



## 闭包 clojure

上面我们已经讨论了lambda，lambda没有基本类型，也没有定义关于基本类型的操作，下面来讨论如何使用lambda来解决现实中的问题。

### 丘奇规约

丘奇规约用于构建基本类型及其操作，可用于更高阶的表达式中

丘奇规约可以构建如下几种基本类似

+ boolean

+ Integer

+ pair

+ list

+ tagged union

  每一种基本类型都有对应的操作。这些构建了lambda演算的基石，下面我们简单介绍一下。

### 丘奇boolean

boolean的逻辑中，只有true和false两个值，lambda没有提供任何基本类型，我们可以通过丘奇编码来定义。我们将true和false定义如下

```
true = λa.λb.a  等价于java中(a,b)->a
false = λa.λb.b  等价于java中(a,b)->b
```

这两个lambda都是两个参数的函数，true返回第一个参数，false返回第二个参数.

除了定义基本类型的值，我们还需要一些操作符来完善我们的运算语义。

```
and=λp.λq.p q p
or=λp.λq.p p q
```

直接看定义可能不太直观，我们来推算一下

```
and操作，当两个参数均为true时返回true，将上面true和false的表达式代入
(λp.λq.p)(λa.λb.a)(λa.λb.a)
[p:=(λa.λb.a)]
(λq.λa.λb.a)(λa.λb.a)
[q:=λa.λb.a]
λa.λb.a
结果为true

继续假设参数1false，参数2true
(λp.λq.p)(λa.λb.b)(λa.λb.a)
[p:=(λa.λb.b)]
(λq.λa.λb.b)(λa.λb.a)
[q=(λa.λb.a)]
λa.λb.b

其他情况类似，可以看到符合and的逻辑
```

### 丘奇数字（church numerals）

丘奇数字用于使用lambda描述自然数。表示n的高阶函数是基本函数 ***f*** 的n次组合。

```
0 = x
1 = f x
2 = f(fx)
...
n = f(f(f...(fx)))
```

转为lambda表示如下

```
0 = λf.λx.x
1 = λf.λx.fx
2 = λf.λx.f(f(x))
...
n = λf.λx.f(f(f...(fx)))
```

### 开始构建基石
闭包内置了匿名函数，正好可以用于模拟lambda。例如一个自举函数可能是下面的格式
```
  (fn [x] x)
```
+ fn声明这是一个函数
+ \[x\]声明参数
+ x是方法体
它等价于上面的
```
  (λx.x)
```

## 总结
通过丘奇编码，我们可以用闭包来表示lambda，而[丘奇编码是图灵完备](https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis)的。