---
layout: post
title: "零拷贝"
tags: ["zero copy","linux"]
---
### 普通的读写操作

linux下，应用程序通过read系统调用来将文件内容读取到内存中。

首先看一下linux read函数声明

```cpp
        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t count);
```

read函数需要三个参数：

+ 文件描述符fd，即要读取的文件
+ 一个缓冲区起始地址，文件内容将被读取到内存中这个地址开始的一块内存
+ 读取长度，即要读取的字节数

read函数会从文件***fd***中读取***count***个字节到缓冲区***buf***中。

buf是应用程序自己内存中开辟的一块缓冲区，调用read函数后，控制权交给操作系统，由操作系统执行读取操作。
切换到内核空间执行。

操作系统接收到用户读取文件命令后，开始从磁盘读取文件到内存，但操作系统并不会直接将内容读取到用户指定的缓冲区，
因为操作系统做了缓存优化，磁盘I/O开销很高，所以操作系统会将内容暂时缓存下来，后续如果有同样的读取要求，直接
读取缓存的数据即可。因此操作系统在内核空间也会开辟一块缓冲区，先将数据读到内核缓冲区，再复制到用户的缓冲区。
操作系统有自己的机制来管理这部分缓存。

同样来看一下write函数声明

```cpp
     #include <unistd.h>
     ssize_t write(int fd, const void *buf, size_t count);
```

参数和read函数完全相同，write函数会将***buf***中***count***个字节写入文件***fd***中。

类似的，操作系统对write也进行了缓存，并不会直接写入磁盘，而是暂存到内核缓冲区，在合适的时机写入磁盘。

> 一般情况下，cpu需要参与*磁盘到内核缓冲区*、*内核缓冲区到用户缓冲区*两次复制，其中磁盘到缓冲区这一步由于磁盘
> I/O速度过慢，非常浪费cpu性能，所以通常会使用DMA技术，将这部分复制工作交由DMA来执行，将cpu解放出来执行其他
> 操作。

### mmap

[mmap](https://man7.org/linux/man-pages/man2/mmap.2.html)用于将磁盘上的文件映射到用户内存地址中，
这个api包含了mmap和munmap两个函数， 分别用于创建映射和取消映射

```cpp
        #include <sys/mman.h>
        void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
        int munmap(void *addr, size_t length);
```

+ mmap:在调用方的虚拟地址空间创建一个新的映射，将文件***fd***偏移量为***offset***开始的长度为***length***
  的数据映射到起始地址为***addr***的用户地址空间。
  ***prot***参数表明访问模式（读、写、执行，并且不能与打开文件的访问模式冲突），***flag***参数控制对映射部分的修改
  是否对其他映射了同样区域的进程可见。可以配置为共享或者私有（还有一个特殊的选项：匿名，表示该区域不映射到任何文件，malloc
  函数——用于申请内存的函数，会通过这个选项分配打的内存空间），如果配置为私有，
  那么内核会通过copy on write来保证当前应用对该区域的修改不会影响到其他映射到该区域的进程，并且如果配置为私有，
  该修改不会被写入文件。

+ munmap:用于将mmap占用的内存释放

通过mmap，我们可以像操作已经加载到内存中的文件一下操作还在磁盘上的文件，底层由操作系统会透明读/写磁盘文件到缓冲区（如果
访问的数据已经在缓冲区，那么可以直接取得，如果数据尚未从磁盘加载，由操作系统自动加载）。

进一步的，mmap因为直接映射到内核缓冲区，省去了read调用中内核缓冲区到用户缓冲区的复制操作。write因为需要将用户修改后的数据
写入内核缓冲区，这一步无法避免。

### sendfile

