---
layout: post
title: "零拷贝"
tags: ["zero copy","linux"]
---

### 普通的读写操作

linux下，应用程序通过read系统调用来将文件内容读取到内存中。

首先看一下linux read函数声明

```cpp
        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t count);
```

read函数需要三个参数：

+ 文件描述符fd，即要读取的文件
+ 一个缓冲区起始地址，文件内容将被读取到内存中这个地址开始的一块内存
+ 读取长度，即要读取的字节数

read函数会从文件***fd***中读取***count***个字节到缓冲区***buf***中。

buf是应用程序自己内存中开辟的一块缓冲区，调用read函数后，控制权交给操作系统，由操作系统执行读取操作。
切换到内核空间执行。

操作系统接收到用户读取文件命令后，开始从磁盘读取文件到内存，但操作系统并不会直接将内容读取到用户指定的缓冲区，
因为操作系统做了缓存优化，磁盘I/O开销很高，所以操作系统会将内容暂时缓存下来，后续如果有同样的读取要求，直接
读取缓存的数据即可。因此操作系统在内核空间也会开辟一块缓冲区，先将数据读到内核缓冲区，再复制到用户的缓冲区。
操作系统有自己的机制来管理这部分缓存。

同样来看一下write函数声明

```cpp
     #include <unistd.h>
     ssize_t write(int fd, const void *buf, size_t count);
```

参数和read函数完全相同，write函数会将***buf***中***count***个字节写入文件***fd***中。

类似的，操作系统对write也进行了缓存，并不会直接写入磁盘，而是暂存到内核缓冲区，在合适的时机写入磁盘。

> 一般情况下，cpu需要参与*磁盘到内核缓冲区*、*内核缓冲区到用户缓冲区*两次复制，其中磁盘到缓冲区这一步由于磁盘
> I/O速度过慢，非常浪费cpu性能，所以通常会使用DMA技术，将这部分复制工作交由DMA来执行，将cpu解放出来执行其他
> 操作。

### mmap

[mmap](https://man7.org/linux/man-pages/man2/mmap.2.html)用于将磁盘上的文件映射到用户内存地址中，
这个api包含了mmap和munmap两个函数， 分别用于创建映射和取消映射

```cpp
        #include <sys/mman.h>
        void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
        int munmap(void *addr, size_t length);
```

+ mmap:在调用方的虚拟地址空间创建一个新的映射，将文件***fd***偏移量为***offset***开始的长度为***length***
  的数据映射到起始地址为***addr***的用户地址空间。
  ***prot***参数表明访问模式（读、写、执行，并且不能与打开文件的访问模式冲突），***flag***参数控制对映射部分的修改
  是否对其他映射了同样区域的进程可见。可以配置为共享或者私有（还有一个特殊的选项：匿名，表示该区域不映射到任何文件，malloc
  函数——用于申请内存的函数，会通过这个选项分配打的内存空间），如果配置为私有，
  那么内核会通过copy on write来保证当前应用对该区域的修改不会影响到其他映射到该区域的进程，并且如果配置为私有，
  该修改不会被写入文件。

+ munmap:用于将mmap占用的内存释放

通过mmap，我们可以像操作已经加载到内存中的文件一下操作还在磁盘上的文件，底层由操作系统会透明读/写磁盘文件到缓冲区（如果
访问的数据已经在缓冲区，那么可以直接取得，如果数据尚未从磁盘加载，由操作系统自动加载）。

进一步的，mmap因为直接映射到内核缓冲区，省去了read调用中内核缓冲区到用户缓冲区的复制操作。

### sendfile

考虑这样一个场景：我们从磁盘中读取一个文件，然后原封不动写入另一个文件。
**mmap**对于读操作，可以免掉从内核读缓冲区到用户缓冲区的复制操作，但是写操作还是需要调用传统的write方法，将用户空间写缓冲
区的数据复制到内核空间写缓冲区。既然我们不需要修改文件内容，是不是可以直接将内核读缓冲区的数据直接写入到内核写缓冲区。

linux提供了sendfile系统调用

```cpp
    #include <sys/sendfile.h>
    ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

将输入文件***in_fd***从偏移量***offset***开始的***count***个字节复制到输出文件***out_fd***。整个操作都在内核空间进行，
免去了read和write的两次内核和用户空间数据复制开销。

### splice

目前为止我们都基于输入输出都是文件的情况进行了讨论，实际上，在linux下，[一切皆是文件](_posts/2021-08-28-零拷贝.md:95)。
而目前我们讨论的api传递的输入输出参数都是文件描述符，所以实际我们常用的读写socket（linux下socket也是一个文件描述符）等
也可以用read/write系统调用来实现。但是mmap和sendfile则有一些限制：

+ mmap只能作用于普通文件
+ sendfile的输入fd必须是可以用mmap操作的fd，即一个常规文件。输出fd在linux2.6.33之前只能是socket，之后可以是任意的文件描述符

为了实现任意fd之间的数据传输，引入了splice系统调用，将数据拼接到管道或者从管道拼接数据（即可以从管道读取或者输出到管道），它无需
内核空间的数据复制或用户空间的数据复制。

```cpp
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <fcntl.h>

       ssize_t splice(int fd_in, off64_t *off_in, int fd_out,
                      off64_t *off_out, size_t len, unsigned int flags);
```

参数包括输入输出的文件描述符、输入输出的offset、长度、flag等等，和上面介绍的差不多。

需要注意，输入输出至少有一个是管道（实际上2.6.30之前，必须只有一个是管道，2.6.30之后两边都可以是管道）

### 对比一下这些调用

| 调用| 输入                     | 输出                     | 内核到用户空间拷贝 | 用户到内核空间拷贝 |内核空间相互拷贝|
|---|------------------------|------------------------|-----------|-----------|---|
|read| 任何类型的fd                | \-                     | 一次        | 否         |否|
|write| \-                     | 任何类型fd                 | 否         | 一次        |否|
|read/write结合| 任何类型fd                 | 任何类型fd                 | 一次        |一次|否|
|mmap| 普通文件fd                 | \-                     |否|否|否|
|sendfile| 同mmap                  | 旧版本只支持socket，新版本支持任意fd |否|否|一次|
|splice| 任意类型fd（但是它和输出至少有一个是管道） | 任意类型fd（但是它和输入至少有一个是管道） |否|否|否|

### 总结
这里我们单以读写文件为例（linux下fd范围比较大），用户操作文件需要将数据从磁盘加载到内存中，因此会在程序中开辟一块缓冲区用于存放
读入的数据。操作系统为了减少I/O的开销，自己做了一层缓存，所以数据会先被加载到操作系统的缓存缓冲区，然后再复制到用户的缓冲区。同理，
用户写操作也会先写入操作系统缓冲区，最后被写入磁盘或者socket。

mmap通过直接将磁盘上的文件映射到用户地址空间（用户真正访问时，会通过page fault将磁盘上的数据加载到内核缓冲区，但是不需要再复制到
用户缓冲区），省去了读操作的内核到用户空间的复制开销。**但是要注意性能也并不绝对比read高，因为mmap需要修改内核的一些数据结构，而且
mmap以内存页为单位读取数据（mmap大小只能是内存页大小的整数倍），read以字节为单位读取数据，当读取文件很小时，read性能可能更高一些**


### 一切皆文件

unix系统下，一切皆文件描述的是：不管是文件、目录、socket、管道，抽象文件系统抽象为一个文件描述符（file descriptor）。

通过抽象成文件描述符，我们可以直接通过read和write方法和硬件以及其他设备交互，简化了编码

#### linux支持的文件类型

linux支持七种文件类型，通过ls -l命令可以查看具体文件的类型。

进入到 /dev 目录下，执行ls -l命令，因为这个目录下文件类型比较多，结果大概如下

```shell
crw-rw-rw-  1 root tty       5,     0 8月  17 11:48 tty
brw-rw----  1 root disk      7,     0 8月  10 08:52 loop0
drwxr-xr-x  2 root root             0 8月  10 08:52 hugepages
```

可以看到输出的第一个字母（这里的c、b、d）不完全一样，这个字母就表示文件类型。对应的字母表示会在下面的文件类型介绍时括号中
标出。

+ 普通文件(-)，比如文本、二进制、图片等，通过touch或者vi都可以创建
+ 目录文件(d)，可以通过mkdir创建目录
+ 链接文件(l)，可以通过ln命令创建
+ 字符设备文件(c)，提供串行的输入输出流，终端（tty）就是一个字符设备
+ 块设备文件(b)，硬件设备的文件，大部分位于/dev目录下。可以通过fdisk对磁盘进行分区来增加新的块设备
+ socket文件(s)，通过socket系统调用创建
+ 命名管道文件(p)，除了命令行中多个命令之间使用 | （比如ls | grep txt）自动创建外，也可以使用[mkfifo](_posts/20220-8-01-linux部分命令.md:50)
  命令创建

> 还有一种文件类型是Solaris系统特有的，Door 文件，ls命令展示为D，用于进程间通信



It is highly advisable to create own systemd services or udev rules
to run scripts during boot instead of using this file.
