---
layout: post
title: "正则相关替换及linux命令"
tags: ["linux", "正则表达式","sed","grep","perl"]
---

linux下处理正则表达式通常用sed，grep，perl这三个命令，其中perl的正则表达式最为强大，而且本身perl是脚本
语言，因此可以完成更复杂的处理。sed对一些正则扩展（比如环视）没有很好的支持，通常用语简单情况下的替换。grep
主要用于查找，因为其可以指定-P参数来使用perl的正则解析，因此如果只是查找的情况，可以用grep加-P参数代替perl。

## grep
一般情况下使用grep就可以，习惯上直接使用-P蚕食使用perl的语法，grep的-P参数支持环视等高级功能。

### -z参数
使用-z参数可以将整个文件视为一行文本，但是输出结果会用\0，即NUL分隔，使用vim打开会看到^@，这时可以通过vim
替换为换行
```shell
:%s/^v000/\r/g
```
注意上面的^v，表示ctrl-v，即按下ctrl-v再输入000,即可输入^@
## sed
sed命令用于正则匹配和替换文本。

sed命令支持标准正则和扩展正则，默认情况下是标准正则，这种正则过于简陋，一般都使用-E参数开启扩展正则。通常情况
下我们只关系匹配并替换之后的文本，因此会带上-n参数，让sed静默运行，不带-n那么sed会将文本整个输出一遍。

```shell
$ cat a.txt | sed -nE 's/{regex}/{replace}/p'
```
sed使用反斜杠加序号来进行反向引用，比如反向引用第一个就是\1
```shell
$ echo "aaa bbb" | sed -nE 's/^(.*) (.*)$/\2 \1/p'
bbb aaa
```

### sed命令i参数使用注意
-i参数用于原地替换文件中的匹配的文本
```shell
# cat a.txt 
aaa
bbb
ccc
ddd
# sed -i 's/aaa/eee/' a.txt
# cat a.txt 
eee
bbb
ccc
ddd
```
但是和-E参数结合使用时，必须将-E参数放在-i参数前面，否则正则表达式可能识别失败。

## perl
perl的正则是全能选手，在命令行中，通常用 ***-ne*** 参数来
perl主要用于复杂正则的替换，因为sed不支持某些正则的高级特性，通常情况下以下命令和sed效果是一样的
```shell
$ echo "aaa bbb" | perl -ne 'print if s/^(.*) (.*)$/\2 \1/'
bbb aaa
```
注意表达式，相比sed新增了print if，用于匹配到时打印，因此也无需sed的p参数。

perl表达式还支持if，else，因此如果有多种匹配，可以通过perl实现
```shell
$ less input.txt | perl -ne 'if(s/^.*id="cur.*".*value="([^"]+)".*$/\1/){print $_}elsif(s/^\s*<li>\s*<i>([^<]+)<.*<strong>([^<]+)<.*$/\1 \2/){print $_}elsif(s/^.*query\?q=([^"]+)".*nbsp;([^<]+).*$/\1 \2 /){print $_}'
```
可以看到这是个比较复杂的正则，由单个语句的print if改为了 if(){print}elsif(){print}的句式。注意
$_，这个是perl中的特殊参数，perl会把运算结果储存在该变量，因此这里直接打印即可

补充（2023年）：
上面的语法实际上可以简化为如下
```shell
$ less input.txt | perl -ne '{print if /.*value/} {print if s/(.*)Ada(.*)/\1---\2/}'
```
类似于awk的语法，但是不需要filter，每个if单独放在一个{}内即可，perl会按顺序执行每个{}块。
awk的语法如下：
```shell
$ less input.txt |awk '/.*Adapter.*/ {print}'
```
需要一个//包括起来的正则表达式作为匹配

## 工具选择
单个正则使用sed，多个正则使用perl或者awk均可，注意sed和awk的正则都比较简单，需要高级功能只能选择perl

### 跨多行匹配
1、grep的-z参数，将文件视为一行
2、sed的范围选择，sed -nE '/some/,/another/p' file


## 正则转换反向引用大小写

\U指定之后的文本转大写，\E结束大写转换，\L指定之后的文本转小写，\E结束转换。如果不结束转换，\U或者\L或作用到结尾
```shell
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1 \2/p'
AAA BBB
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1\E \2/p'
AAA Bbb
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1\E \L\2/p'
AAA bbb
```
如果\E和下一个\U或者\L相邻，那么\E可以省略。

需要注意，\U和\L不止作用于反向引用，用户的文本也会受影响
```shell
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1aaa\E \L\2CCC/p'
AAAAAA bbbccc
```
所以\U和\L最好结合\E使用

## 常用对比
| 标题  | idea        | sed                       | grep                            | perl               |
|-----|-------------|---------------------------|---------------------------------|--------------------|
|常用参数| 无           | -nE，不输出原始文本，替换通过p参数打印匹配数据 | -E开启扩展正则，-P使用perl正则引擎，perl引擎更强大 | -ne这样类似于sed，逐行处理文本 |
|反向引用| $+序号($1,$2) | \\+序号(\1,\2)              |-|\\+序号(\1,\2)|
