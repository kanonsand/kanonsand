---
layout: post
title: "正则相关替换及linux命令"
tags: ["linux", "正则表达式","sed","grep","perl"]
---

linux下处理正则表达式通常用sed，grep，perl这三个命令，其中perl的正则表达式最为强大，而且本身perl是脚本
语言，因此可以完成更复杂的处理。sed对一些正则扩展（比如环视）没有很好的支持，通常用语简单情况下的替换。grep
主要用于查找，因为其可以指定-P参数来使用perl的正则解析，因此如果只是查找的情况，可以用grep加-P参数代替perl。

## grep
一般情况下使用grep就可以，习惯上直接使用-P蚕食使用perl的语法，grep的-P参数支持环视等高级功能。

### -z参数
使用-z参数可以将整个文件视为一行文本，但是输出结果会用\0，即NUL分隔，使用vim打开会看到^@，这时可以通过vim
替换为换行
```shell
:%s/^v000/\r/g
```
注意上面的^v，表示ctrl-v，即按下ctrl-v再输入000,即可输入^@
## sed
sed命令用于正则匹配和替换文本。

sed命令支持标准正则和扩展正则，默认情况下是标准正则，这种正则过于简陋，一般都使用-E参数开启扩展正则。通常情况
下我们只关系匹配并替换之后的文本，因此会带上-n参数，让sed静默运行，不带-n那么sed会将文本整个输出一遍。

```shell
$ cat a.txt | sed -nE 's/{regex}/{replace}/p'
```
sed使用反斜杠加序号来进行反向引用，比如反向引用第一个就是\1
```shell
$ echo "aaa bbb" | sed -nE 's/^(.*) (.*)$/\2 \1/p'
bbb aaa
```

### sed命令i参数使用注意
-i参数用于原地替换文件中的匹配的文本
```shell
# cat a.txt 
aaa
bbb
ccc
ddd
# sed -i 's/aaa/eee/' a.txt
# cat a.txt 
eee
bbb
ccc
ddd
```
但是和-E参数结合使用时，必须将-E参数放在-i参数前面，否则正则表达式可能识别失败。

### sed命令a(append)和i(insert)注意
a用于在指定行后面追加一行,i用于指定行前插入一行
```shell
$ cat a.txt
aaa
bbb
ccc
ddd
$ cat a.txt | sed -E '/aaa/a1'
aaa
1
bbb
ccc
ddd
$ cat a.txt | sed -E '/aaa/i1'
1
aaa
bbb
ccc
ddd
```
但是用在组合命令中时a和i需要另外一种方式(这种方式所有情况都可以使用,但是写起来比较麻烦,因此简单的一般都用上面的写法)
```shell
//将aaa的行替换成bbb并在行后面添加一个只有1的行
$ cat a.txt | sed -E '/aaa/{s/a/b/g;a1;}'
//报以下异常
sed: -e expression #1, char 0: unmatched `{'
//修改成如下语句
$cat a.txt |sed -E '/aaa/{s/a/b/g;a\
 1
 ;}'

bbb
1
bbb
ccc
ddd
//追加多行,需要继续用反斜线转义
$ cat a.txt |sed -E '/aaa/{s/a/b/g;a\
1\
1   
;}'
bbb
1
1
bbb
ccc
ddd
```
> 注意以上的例子,命令组的}必须要新起一行,还有a后面必须有一个反斜线


### sed模式匹配需要匹配的字符包含多个/
对于s命令,直接在s后面用其他符号换掉/,之后全部用这个符号即可(在vim中也是这样)
```shell
$ echo '/a/b/c' | sed -E 's#/#1#g'
1a1b1c
```
尤其是在/特别多的时候,这样可以省去每次都转义

对于一般的模式匹配,则需要用反斜线后跟分隔符的形式告诉sed要使用的分隔符
```shell
$ echo '/a/b/c' | sed -E '\#/#p'
/a/b/c
/a/b/c
```
上面的例子中就用了#作分隔符

### sed b 和 t的使用
b和t都会用到标记，b一般用对于符合条件的字符串跳过一部分处理逻辑,通常是向后跳转
```shell
$ seq 3|sed -E '/1/bx; s/(.)/\1\1/g; :x; s/(.)/\1\1/g'
11
2222
3333
```
上面的例子，标记是x，匹配的条件是包含1，包含1的直接跳过第一次倍增逻辑，其他的则是完整执行两次倍增逻辑

t用在循环中，一般用于符合条件时继续循环，所以通常是向前跳转
```shell
seq 10 | sed -E '/^/{:x; N; s/\n([0-9])$/\1/; tx;}'
123456789
10
```
在起点设置标记x，不断读取下一行，如果下一行只有一位数字则将其拼接到当前的字符串末尾，去掉换行符，然后跳回到标记x的位置继续读取，读到10的时候因为不满足条件循环自动终止

注意处理命令是否在{}内的语义区别，t的例子中将命令包含在了{}内，b的例子中没有,如果将b的例子命令也包含在{}内，效果如下
```shell
seq 3|sed -E '/1/{bx;s/(.)/\1\1/g;:x;s/(.)/\1\1/g}'
11
2
3
```
可以看到只对匹配到模式的字符串进行了处理并直接跳到了标记位置，此时b没有意义，所以{}内的逻辑只有匹配到模式的字符串才会一起执行，b通常用于同时处理匹配和不匹配的字符串，对于匹配的跳过一部分逻辑，所以b通常不和{}一起使用。而使用t时，我们通常需要通过模式来确定循环的起点，对于非起点我们并不想处理，所以一般都和{}一起使用。

### sed y替换
y用于将字符一对一替换
```shell
$ seq 3 |sed 'y/123/xxx/'
x
x
x

$ seq 3 |sed 'y/1-3/a-c/'
a
2
c
```
可以看到sed不支持范围替换，需要范围替换使用tr
```shell
$ seq 3 |tr '1-3' 'a-c'
a
b
c
```
这样对于连续的字符就可以简化输入,注意如果tr第一个的范围比第二个的范围大，那么第一个和第二个在相等的部分一一对应，超出部分使用第二个的最后一个字符


## perl
perl的正则是全能选手，在命令行中，通常用 ***-ne*** 参数来
perl主要用于复杂正则的替换，因为sed不支持某些正则的高级特性，通常情况下以下命令和sed效果是一样的
```shell
$ echo "aaa bbb" | perl -ne 'print if s/^(.*) (.*)$/\2 \1/'
bbb aaa
```
注意表达式，相比sed新增了print if，用于匹配到时打印，因此也无需sed的p参数。

perl表达式还支持if，else，因此如果有多种匹配，可以通过perl实现
```shell
$ less input.txt | perl -ne 'if(s/^.*id="cur.*".*value="([^"]+)".*$/\1/){print $_}elsif(s/^\s*<li>\s*<i>([^<]+)<.*<strong>([^<]+)<.*$/\1 \2/){print $_}elsif(s/^.*query\?q=([^"]+)".*nbsp;([^<]+).*$/\1 \2 /){print $_}'
```
可以看到这是个比较复杂的正则，由单个语句的print if改为了 if(){print}elsif(){print}的句式。注意
$_，这个是perl中的特殊参数，perl会把运算结果储存在该变量，因此这里直接打印即可

补充（2023年）：
上面的语法实际上可以简化为如下
```shell
$ less input.txt | perl -ne '{print if /.*value/} {print if s/(.*)Ada(.*)/\1---\2/}'
```
类似于awk的语法，但是不需要filter，每个if单独放在一个{}内即可，perl会按顺序执行每个{}块。
awk的语法如下：
```shell
$ less input.txt |awk '/.*Adapter.*/ {print}'
```
需要一个//包括起来的正则表达式作为匹配

## awk
awk也支持正则表达式,但是对于单行处理,awk写起来比较麻烦,并且awk的正则表达式没有perl或者grep的-P模式一样强大,所以用的比较少.但是在处理多行文本时,特别是用sed不太好处理的情况下,awk可能是一个解决方案.

考虑如下场景:通过某种方式生成了一个文件,正常情况下文件中三行为一组,分别表示数字,时间和内容,如下:
```shell
$ cat a.txt
1
2022-01-01 11:11:11
context1
2
2022-01-01 11:11:11
context2
3
2022-01-01 11:11:11
context3
```
但是其中有一些异常数据,这些数据缺少了数字,如下
```shell
$ cat a.txt
1
2022-01-01 11:11:11
context1
2
2022-01-01 11:11:11
context2
2022-01-01 11:11:11
context3
```
因为后续要按照三行一组的格式处理文件,所以想要补全这个文件,确实的数字补为0,使用awk就可以完成这个功能,使用一个遍历记录前一行,如果本行是日期,判断前一行是不是数字,如果不是,则输出0和本行,如果是则只输出本行,其他不是日期的行正常输出,代码如下
```shell
$ cat a.txt |awk ' BEGIN{ pre = "" } !/^[0-9]+-/{print $0} /^[0-9]+-/{if(pre ~ /^[0-9]+$/){ print $0 } else { print 0; print $0 }} {pre=$0}'
1
2022-01-01 11:11:11
context1
2
2022-01-01 11:11:11
context2
0
2022-01-01 11:11:11
context3
```
这个例子里用正则表达式 ^[0-9]+- 来匹配日期(并不严谨,但是能从其他数据中区分开就足够了),没有匹配上的(!/regex/的部分)直接输出,匹配上的(/regex/部分)进行判断,pre变量记录了前一行,如果前一行全是数字(if里面的正则表达式判断,awk的if中使用 ***str ~ /regex/*** 的格式进行正则判断),则直接输出本行,否则输出0再输出本行;最后,每一行都要更新pre变量


## 工具选择
单个正则使用sed，多个正则使用perl或者awk均可，注意sed和awk的正则都比较简单，需要高级功能只能选择perl

### 跨多行匹配
1、grep的-z参数，将文件视为一行
2、sed的范围选择，sed -nE '/some/,/another/p' file


## 正则转换反向引用大小写

\U指定之后的文本转大写，\E结束大写转换，\L指定之后的文本转小写，\E结束转换。如果不结束转换，\U或者\L或作用到结尾
```shell
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1 \2/p'
AAA BBB
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1\E \2/p'
AAA Bbb
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1\E \L\2/p'
AAA bbb
```
如果\E和下一个\U或者\L相邻，那么\E可以省略。

需要注意，\U和\L不止作用于反向引用，用户的文本也会受影响
```shell
$ echo "aaa Bbb"|sed -nE 's/^(.*) (.*)$/\U\1aaa\E \L\2CCC/p'
AAAAAA bbbccc
```
所以\U和\L最好结合\E使用

## 常用对比
| 标题  | idea        | sed                       | grep                            | perl               |
|-----|-------------|---------------------------|---------------------------------|--------------------|
|常用参数| 无           | -nE，不输出原始文本，替换通过p参数打印匹配数据 | -E开启扩展正则，-P使用perl正则引擎，perl引擎更强大 | -ne这样类似于sed，逐行处理文本 |
|反向引用| $+序号($1,$2) | \\+序号(\1,\2)              |-|\\+序号(\1,\2)|
