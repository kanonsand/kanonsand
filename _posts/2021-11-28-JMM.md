---
layout: post
title: "Java内存模型"
tags: ["内存模型", "jsr133", "java"]
---

java内存模型（Java memory model）的一些知识点.

### 什么是内存模型

现代多处理器系统中，处理器通常有多级的缓存，这些缓存提高了数据访问速度，减少了内存总线的访问冲突，所以提高了整个系统的性能。但是，如果多个处理器访问同一块内存地址，在什么情况下他们可以看到相同的值呢？

内存模型就在处理器层面规定了什么情况下其他处理器写入的数据可以被当前处理器看到，或者当前处理器写入的值可以被i其他处理器看到。一些处理器实现了强内存模型，任何情况下所有处理器看到的值都是一致的，而另外一些处理器实现了较弱的内存模型，通过一些特殊的指令（称为内存屏障），要求flush当前处理器的缓存或者invalidate当前处理器的缓存来让其他处理看到当前处理器的值或者看到其他处理器的值。这些屏障通常在有锁的情况下被使用，并且在更高的语言层面来看是不可见的。

通常情况下强内存模型实现会简单一些，因为可以减少内存屏障的使用，但是实际上在某些强内存模型中，内存屏障也是必需的。现在的趋势更多使用弱内存模型，因为弱内存模型减轻了缓存一致性的压力，使得扩展更多处理器或者更大内存更加灵活。

编译器的指令重排会使得让写入的数据被其他处理器看到这个问题更加复杂。例如，在不改变程序语义的情况下，编译器可以选择将某个写操作推迟，而如果某条写指令被推迟，其他处理器只能在写指令真正被执行后才能看到该值，这个效果和缓存带来的问题是一样的。而且，写操作甚至可以提前被执行，这种情况下其他处理器相当于在这条指令“真正应该被执行“之前就拿到了该指令的结果。而指令重排是为了给编译器、运行时、硬件更高的灵活性以取得更好的性能。

### 其他语言也有内存模型吗

大部分其他语言，比如c和c++，并不是直接为了多线程设计的，所以它们对内存访问的保证更依赖于使用的线程库（例如pthread）、编译器甚至运行的平台。

### JSR133是什么

从1997年开始，从java语言规范第17章规定的内存模型中，发现了多个缺陷，这些缺陷导致了一系列令人困惑的现象（比如final变量被观察到改变了），并且破坏了编译器对语言的通用优化。

JMM是一个很有野心的承诺，这是第一次某个语言尝试跨体系结构提供并发的一致性语义。不幸的是，定义一个既一致又符合直觉的内存模型比想象的要困难，jsr133重新定义了内存模型，修复了之前的缺陷。为了达成这个目的，final和volatile的语义也发生了变化。

### JSR133的目标

1、保留当前已有的安全保证，比如类型安全，并加强其他的安全性。比如，变量不可以凭空产生，某个线程观察到的变量必须是某些线程合理的写入的值。

2、一个正确实现同步语义的程序应该尽可能简单并且符合直觉

3、未正确或完整实现同步语义的程序也应该被定义，以最小化潜在的安全危害

4、程序员应该可以自信的推理出多线程程序如何与内存进行交互

5、可以为广泛使用的的硬件体系结构提供正确的、高性能的jvm实现

6、新的初始化安全性：如果对象被合理的初始化（初始化过程中没有将该对象的引用暴露出去），那么所有线程访问这个对象时，无需同步，也可以读取其在构造函数中初始化的final字段的值

7、最小化对现有代码的冲击

### 之前的内存模型有什么问题

1、直觉上来说，如果一个变量被final修饰，那么访问该变量无需同步。但是在之前的模型中，这个特性并没有被保证，final和普通变量并没有区别对待---这就意味着构造函数初始化final变量时必须用synchronized修饰，来保证所有线程都能看到构造函数初始化之后的值。

2、旧的模型运行volatile修饰的写可以和其他非volatile指令的读写重排，违反直觉

### synchronization做了什么

synchronization有很多方面，最广为人知的就是互斥，一次只能由一个线程拿到monitor，其他线程在这个线程释放monitor之前都无法进入该代码块。

实际上除了互斥，synchronization还有其他语义：当退出monitor时，需要将变量刷写入主存以让其他线程可以取得该变量最新的值；当我们获取到monitor，执行代码块之前，需要将本地缓存的变量失效，重新从主存中加载该变量，确保取得之前获得该monitor线程写入的最新值。

新的内存模型规定了部分内存操作（读、写、lock、unlock）和线程操作（start、join）的顺序，规定某些操作***happen before***其他操作，当某个操作happen before另一个操作，jvm会确保前一个操作指令不会被重排到后一个操作之后，并且确保前一个操作的结果对后一个操作可见。

1、同一个线程内按照代码顺序，前面的操作happen before后面的操作。这个并不是说不允许指令重排，这条是针对于前后相关的操作，例如 int a,b; a=1; b=a+1;int c=3;那么b只能等于2。而c因为和前面的不相关，所以编译器可以将c的赋值操作重排到其他位置。

2、对于同一个monitor来说，unlock操作happen before后续的lock操作

3、对于一个volatile修饰的变量，write操作happen before后续对该变量的read

4、一个线程的start()方法happen before该线程内部所有操作

5、一个线程内所有操作happen before任何join这个线程的其他线程join()方法成功返回

### volatile做了什么

在旧的模型中，对volatile变量的访问无法被重排序，但是非volatile和volatile变量的访问指令可以被重排序，这使得将volatile变量作为一个共享信号无法实现。

在新的模型中，对volatile变量的访问依然无法重排序，但是额外限制了对volatile变量周围其他变量的访问操作进行重排，volatile包括synchronization的可见性语义，可以说是“半同步”，在新的内存模型中，一个线程在某个volatile变量之前写入的非volatile变量，在该volatile变量写入后，当另外一个线程访问这个volatile变量时，之前线程写入的非volatile变量也是可见的。不太好理解，例子如下：

```java
class VolatileExample{
    int x=0;
    volatile boolean flag = false;
    /**
    这个方法在线程A中执行
    **/
    public void doSomeThingA(){
        x = 5;
        flag = true;
    }
    
    /**
    这个方法在线程B中执行
    **/
    public void doSomeThingB(){
        if(flag == true){
            System.out.println(x);
        }
    }
}
```

上面这个例子中，flag是volatile变量，x是非volatile变量，但是，当线程B读取到flag为true时，尽管x并不是volatile的，但是线程B读到的x也必须是5，而不能是0。java内存模型保证，当线程A写入了一个volatile变量，那么线程B在读取到这个volatile变量的最新值的同时，也可以读到线程A这个volatile变量之前的所有修改（包括对非volatile变量的修改）。这里注意，必须是线程B读取该volatile变量时，可以看到由线程A写入的非volatile变量的值，如果线程A写入了volatile变量，此时还有个线程C，线程C并没有读取volatile变量，那么线程C还是可以从缓存中读取非volatile变量的值，直到线程C也读取该volatile变量。