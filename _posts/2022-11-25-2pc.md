---
layout: post
title: "2pc 两阶段提交"
tags: ["java","分布式"]
---

两阶段协议描述起来比较简单，系统中有一个协调者（coordinator 后续称为C）和多个参与者（site 后续称为S，编号为i的称为Si）。
如名称一样，整个事务T提交分为两个阶段
> 1、prepare阶段
> >这个阶段C在本地写入一个(prepare T)的日志，然后向向每一个S发送一个prepare请求，Si收到请求后，
> 首先记录(prepare T)的日志，然后有如下两个选择：
> >如果可以执行该事务，则在本地执行该事务，同时记录redo log和undo log。本地日志记录(ready T),之后向C返回（ready T）
>
> >如果无法执行改事务（比如与当前在执行的其他事务冲突），本地日志记录(abort T),之后向C返回（abort T）

> 2、commit阶段
> > >如果C收到了所有S的(ready T)响应，表示每个节点都可以提交，那么C本地记录一个(commit T)的日志，之后向所有
> > >S发送(commit T)，要求它们提交事务；
> >
> > >如果C收到了一个或者多个(abort T)响应，表示有些节点无法提交，那么C本地记录一个(abort T)
> > >日志，之后向所有S发送(abort T)消息。
> 
> > >如果S收到了(commit T)，则本地日志写入(commit T)，并提交 prepare阶段的操作
> >
> > >如果S收到了(abort T),则本地日志写入(abort T),回滚prepare阶段的操作

现在重点关注下节点失效后的处理

1、参与者(Site)宕机恢复后的处理
> > 如果Si在发送(ready T)之前就已经宕机，那么C会等待直到超时，超时后视为Si返回了(abort T)
> >如果Si在发送(ready T)之后宕机，那么C会继续提交整个事务
 
当Si恢复时，其会根据本地记录的log来决定如何处理
> > 如果最后日志包含(commit T)，说明事务已成功提交，通过redo log恢复状态
> 
> > 如果最后日志包含(abort T)，说明事务需要回滚，通过undo log回滚
> 
> > 如果最后日志包含(ready T),Si无法判断事务状态，此时需要询问C获取该事务状态，如果此时C不可用，
> > 则需要从其他节点获取该事务状态，如果其他节点也不可用，那么Si必须记录这个错误，定时检测直到联系
> > 到一个节点为止

2、协调者(Coordinator)宕机恢复后的处理

下列情况下不需要C恢复S就可以决定事务的结果
> 所有S日志中都有(commit T)，那么T需要正常提交
> 所有S日志中都有(abort T)，那么T需要被废弃
> 如果存在S日志中没有(ready T)，说明该S没有准备好，或者根本没有收到(prepare T)请求，此时最好放弃该事务

除去上面的三种情况，此时每个S都有一个(ready T)日志，但是都无法确定C宕机前决定abort还是commit该
事务，此时必须等待C恢复才可以决定。

3、