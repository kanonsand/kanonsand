

这里主要基于对inner equal join进行介绍，不过算法同样可以用于其它类型的join

当前有如下两张表：
表R，包含M个数据页，包含m条数据，作为join的驱动表(outter)
表S，包含N个数据页,包含n条数据，作为join的被驱动表(inner)
> 一个数据页包含多条数据，所以通常M>m,N>n

> 本文中时间复杂度基于IO考虑，忽略cpu的计算时间，由于磁盘上的数据是按照数据页加载的，所以对于表R来说，加载整张表的复杂度为M，而不是m，S同理
> 本文是对比不同算法的复杂度，因此忽略了输出结果需要的时间，因为对于每一种算法，输出都是相同的，有相同的复杂度

## nested loop join (嵌套循环)

### simple nested loop join

最朴素的循环算法，对于表R的每条记录，到S中逐条查找，相当于双重for循环，时间复杂度M+m*N
> M是将R表数据全部加载一遍需要的时间，对于R中的每条记录，都需要到S表中循环匹配，而S表一次加载的时间复杂度为N，所以m条记录一共需要m*N

### block nested loop join

相比于朴素算法，本算法基于数据页进行了优化，因为磁盘一次性加载一个数据页，所以对于R已加载到内存的一个数据页r中的数据，同时对比S已加载的一个数据页s的所有记录，复杂度降为M+M*N
> M是将R表全部加载一遍的耗时，对于R的每一页，都需要将S表循环一次，耗时为N，所以M页一共耗时M*N

### index nested loop join

上面两种算法都需要对被驱动表S进行不断的循环查询，如果S表用于join的字段有索引，假设通过索引查询一条数据的时间为常量C，则复杂度为 M+m*C

> M用于R表全部加载一遍，m条记录每条耗时C

## sort merge (有序合并)

如果R表和S表已经对用于join的列进行了排序（建立了索引），复杂度可以降为M+N,如果查询语句指定了join完成后对该字段进行排序，数据库也可能会对原本无序的两张表先分别排序，再进行合并，此时复杂度需要额外算上每张表归并排序（通常情况下数据库buffer不足以容纳整张表，因此一般使用归并排序）的复杂度

> 如果R表和S表中join的字段重复数据很多，复杂度会提高,最坏的情况下如果该字段值完全一样，复杂度退化为M*N，但是实际很少基于重复数据多的字段进行join

## hash join

hash join的思想是使用hash算法对驱动表(outter)的全部数据进行分桶，扫描被驱动表时判断hash值是否存在即可，所以一般分为两个阶段
### basic hash join

1、构建hash，类似于hashmap，key为outter表的join字段，value则看具体实现，可以是完整的数据或者只包含数据id
2、扫描inner表，对没条记录到上面构建的hash中查找是否有相同的值

> 如果outter表比较小，可以构建一个静态的hashmap(也可以看作一个分桶)，如果数据比较大，hashmap可能会超过buffer大小,这时候不得不将一部分数据暂时写回磁盘，但是由于hash的特性，hash结果随机性非常大，如果已经有一部分数据写入磁盘，可能需要频繁和内存里的数据进行交换，因此一种优化方案就是bloom filter，过滤掉不存在于hashmap中的数据，避免一些无效的磁盘内存数据交换

### grace hash join / partitioned hash join

由于普通hash join算法的随机性，当hash桶超过内存限制时会频繁和磁盘上的数据进行交换导致性能下降，本方法是对普通hash join的一个优化
1、选定一个hash算法，同时将outer和inner表进行hash，超出内存的部分写入磁盘，唯一需要保证的是确保outter和inner表hash后的最大桶不超过buffer大小，如果无法满足则递归更换hash算法
2、按照第一步hash出的桶，按顺序从outer和inner对应的桶中取出对应的数据，并且循环匹配，由于这一步在内存中操作，所以速度很快,这也是为什么第一步要求最大桶不超过buffer大小的原因

hash join的复杂度包括R和S表的读入、计算hash并写出、最后合并， 3(M+N)
