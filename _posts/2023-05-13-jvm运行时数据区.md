

JVM定义了多个运行时数据区，其中一些在jvm启动时创建，jvm关闭时销毁，另外一些则是线程专属的，随着线程的创建和销毁存在消失。

## pc寄存器

每个线程都有自己的pc（program counter）寄存器，对于非native的方法，pc寄存器存储当前执行的java指令地址，对于native方法，pc寄存器的值是未定义的。

## java虚拟机栈

每个线程有其私有的java虚拟机栈

## 堆

## 方法区

线程间共享，保存了每个类的结构，例如运行时常量池、字段、方法数据、方法和构造函数的代码等。逻辑上这部分是堆的一部分，但是有的GC实现并不回收这一部分的内存。

## 运行时常量池

一个类或者一个接口的class文件中的constant_pool区域在内存中的表示。属于方法区。

## 本地方法栈

用于执行native方法，部分jvm实现不支持native方法，也不依赖于本地堆栈，那么可能不存在这个区域。通常随着线程的创建而创建



**关于字符串常量池。字符串常量池是java规范中规定了字符串字面量应该指向同一个对象，所以通常有一个字符串常量池，存储字符串字面量，
也可以手动调用字符串的intern方法放入。字符串常量池是所有类共享的，而上面说的运行时常量池是每个类专属的，因为它从类的class文件中
加载而来。在java7之前，字符串常量池位于方法区，7之后，将其移动到了堆区。**


## JVM中对象的表示

Jvm规范没有规定对象在内存中的表现形式，在Oracle的实现中，对象是一个指向句柄的指针，而这个句柄又包含两个指针：其中一个指向一个表，
这个表包含这个对象的方法和一个指向对象所属Class对象的指针，另一个指向对象在堆中的内存。



## 栈帧

一个栈帧在方法被调用时被创建，包含三部分：本地变量的数组、操作数栈、指向当前对象的class的运行时常量池的指针。

特别的，对于实例方法，本地变量数组第一个元素是当前对象的指针，也即this。对于通过类调用的方法则没有这个指针。



<init>方法（实例初始化方法 instance initialization method）

Java编写的构造函数会由编译器自动生成一个<init>方法，因为<init>在java语法中是不合法的方法名，所以无法被外部调用。这个方法只能由
invokespecial指令调用，并且只会在实例初始化时调用。方法放具有所处的构造函数一样的访问权限。该方法在class文件中可以看到。



<clinit>方法（类或接口初始化方法 class or interface initialization method)

一个类或接口最多只有一个该方法，通过该方法类和接口被初始化，该方法没有参数，也没有返回值。

其他在class文件中定义的<clinit>方法无关紧要，因为他们无法被任何jvm指令调用，jvm本身也不会运行他们。

同样<clinit>因为不是合法的java方法标识，所以它由编译器提供，无法被直接调用，该方法不会被任何jvm指令调用，只会在类或接口初始化过程中被间接调用。 