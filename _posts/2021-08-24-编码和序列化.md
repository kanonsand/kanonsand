
---
layout: post
title: "编码和序列化"
tags: ["序列化"]
---

讨论关于序列化的一些讨论。

## 为什么要序列化

内存中的数据保存在对象、结构体、数组、哈希表等一系列数据结构中，这些数据结构对cpu访问很友好（大部分通过指针）。
但是如果想将这些数据存储或者在网络上传输，需要将其编码为一种自包含的字节序列，比如json文档。由于每个进程都
有其独立的进程空间，所以一个程序的指针对其他进程没有意义，因此编码后的字节序列往往和内存中的数据大不相同。

从内存数据到字节序列称为编码（encode），也可以叫序列化（serialization），编组（marshalling），反之从
字节序列到内存数据称为解码（decode），反序列化（deserialization），反编组（unmarshalling）。编组与序列化
的区别在于，编组不仅传递对象的状态，也会传递对象的相关代码（方法）。

## 序列化的选择

### 编程语言自带的序列化

每种编程语言都有自己的序列化和反序列化手段，但是这些语言自带的编码手段往往有如下缺点：

+ 和语言绑定

+ 通常支持反序列化所有的类，但是攻击者可能利用这个特性反序列化恶意类，远程执行代码

+ 通常旨在快速简单的对数据进行序列化，前向后向兼容往往没有考虑

+ 部分实现性能很差，比如java自带的序列化

因此，除非临时使用，否则采用语言自带的序列化往往并不是一个很好地选择。

### json和xml等可读编码

json和xml是两个可以被多种语言使用的标准编码，csv也可以编码，但其功能性较弱。

这三种格式将数据编码为人类可读的格式，但是他们也有一些缺点：

+ xml和csv不区分数值和字符串（除非引用一个外部模式），json虽然区分字符串和数字，但是不区分整数和
浮点数，且无法指定精度
+ 当数值过大时，比如说超过2^53，这个数字超过了IEEE754浮点数的最大值，这就导致基于浮点数的语言
+ （如javascript）处理这些数字会变得不准确
+ json、xml和csv都是以可读字符编码的，无法编码二进制数据，虽然往往通过base64编码来绕开这个限制，但是
需要[额外占用了三分之一的存储空间](fastjson转换byte.md:21)。
+ json和xml都有可选的模式支持，这些模式虽然强大但是复杂，xml模式解析比较普遍，但是对于json许多应用
程序并没有支持其模式，这就导致如果要在不支持模式的程序中使用json或xml，就需要硬编码来解析

***尽管存在这些缺陷，但是json和xml对大部分情况来说已经足够用了***

### 二进制编码

如果只在内部使用，json和xml可能太笨重了，我们可以选择更小的或者更快的数据结构。

尽管为了减少占用，出现了二进制版本的json和xml，但是相较于普通的json和xml，这些二进制版本并没有大范围的支持。

可以选用thrift或者protocol buffer等作为二进制序列化工具。